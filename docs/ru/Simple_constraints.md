---
title: 'Простые ограничения'
---

В платформе на данный момент поддерживается четыре типа *простых ограничений* : *следствие*, *исключение*, *равенство*, *определенность*. Для всех простых ограничений поддерживается механизм *автоматического разрешения*, при включении которого, платформа вместо выдачи ошибки, сама приводит систему в целостное состояние.

| |Следствие|Исключение|Равенство|Определенность|
|---|---|---|---|---|
|Количество свойств|2|2...N|2|1|
|Описание|Если значение одного свойства (*посылка*) не <strong>NULL</strong>, то значение второго свойства (*следствие*) также должно быть не <strong>NULL</strong>|Только одно из значений заданных свойств должно быть не <strong>NULL</strong>|Если значение одного свойство не <strong>NULL</strong> и значение второго свойства не <strong>NULL</strong>, то они должны быть равны|Если все параметры свойства подходят по классам, то для них должно быть задано не <strong>NULL</strong> значение|
|Инструкция|<strong>[=>](Instruction=_.md)</strong>|Пока не реализовано|Пока не реализовано|Опция <strong>NONULL</strong> в задании свойств|
|Автоматическое разрешение|<p>Поддерживаются два режима:</p><br/><ul><br/><li><strong>LEFT</strong> - если посылка изменяется на не <strong>NULL</strong>, то изменить* следствие на не <strong>NULL</strong></li><br/><li><strong>RIGHT</strong> - если следствие изменяется на <strong>NULL</strong>, то изменить посылку на <strong>NULL</strong></li><br/></ul>|Если одно из свойств изменяется на не <strong>NULL</strong>, изменить остальные на <strong>NULL</strong>|Если одно из свойств изменяется на не <strong>NULL</strong> значение, изменить второе на это же значение|<p><strong>AGGR</strong> - если значение свойства изменяется на <strong>NULL</strong>, удалить объекты соответствующие параметрам</p><br/><p><strong>DEFAULT</strong> значение - если добавляются (доклассифицируются) объекты соответствующие классам параметров, изменить значение свойства для этих объектов на значение по умолчанию.</p>|

\* Под изменением на **NULL** \\ не **NULL** понимается :

-   Для [первичного](Data_properties_DATA_.md) свойства - [запись](Property_change_CHANGE_.md) **NULL** или [значения по умолчанию](Built-in_classes.md#defaultvalue) для класса значения этого свойства.
-   Для [принадлежности](Classification_IS_AS_.md) классу - удаление объекта \\ добавление объекта класса, для которого проверяется принадлежность.
-   Для [агрегирующего](Grouping_GROUP_.md) оператора - (только если изменение на не **NULL**) добавление объекта базового класса (**System**.**Object**), изменение на не **NULL** условия агрегирующего оператора, запись во все значения группировок значений соответствующих параметров.

Также как и для обычного [ограничения](Constraints.md), для каждого простого ограничения необходимо задать базовое [событие](Events.md), которое определяет когда будет проверяться заданное ограничение. 

Отметим что ограничение определенности является частным случаем следствия, у которого следствием является свойство, которое должно быть определено, а посылкой является его сигнатура (свойство полученное из него при помощи соответствующего [оператора](Property_signature_CLASS_.md)).

Также существует неявный пятый вид простых ограничений - *уникальность*, но он совмещен с агрегирующим оператором (который получает это самое уникальное значение), поэтому здесь не рассматривается. Вместе со следствиями этот вид ограничений позволяет реализовывать механизм [агрегаций](Aggregations.md). 

### Примеры

```lsf
is(Sku s) = s IS Sku;
// для товара должны быть заданы штрих-код и наименование
is(Sku s) => barcode(s);
is(Sku s) => name(s);


CLASS Invoice;
CLASS InvoiceLine;
invoice = DATA Invoice (InvoiceLine);
is(InvoiceLine l) = l IS InvoiceLine;
// для строки документа должен быть задан документ, и при удалении документа, чтобы удалялись строки этого документа
is(InvoiceLine l) => invoice(l) RESOLVE RIGHT;
// равносильно объявлению document = DATA Invoice (InvoiceLine) NONULL DELETE;

// агрегация для f(a,b) создавать объект класса x, у которого свойство a(x) равняется a, а свойство b(x) равняется b
CLASS A;
CLASS B;
f = DATA BOOLEAN (A, B);

CLASS X;
a = DATA A(X);
b = DATA B(X);
is (X x) = x IS X;

f(a,b) => [ GROUP AGGR X x WHERE x IS X BY a(x), b(x)](a,b) RESOLVE LEFT;
is(X x) => f(a(x), b(x)) RESOLVE RIGHT;
```
